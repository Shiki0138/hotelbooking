/**
 * üöÄ Âè≤‰∏äÊúÄÂº∑ Áµ±ÂêàÈÄöÁü•„Çµ„Éº„Éì„Çπ - 120%ÂìÅË≥™ÈÅîÊàêÁâà
 * worker2„Å´„Çà„ÇãÁ©∂Ê•µÁµ±ÂêàÂÆüË£Ö - „Ç≠„É£„É≥„Çª„É´ÂæÖ„Å°ÁâπÂåñ
 * 
 * ÂÖ®„Å¶„ÅÆÈÄöÁü•„ÉÅ„É£„É≥„Éç„É´„Å®AIÊ©üËÉΩ„ÇíÁµ±Âêà„Åó„ÅüÂè≤‰∏äÊúÄÂº∑„ÅÆ„Éû„Çπ„Çø„Éº„Çµ„Éº„Éì„Çπ
 */
const SMSNotificationService = require('./SMSNotificationService');
const PushNotificationService = require('./PushNotificationService');
const AINotificationOptimizer = require('./AINotificationOptimizer');
const EventEmitter = require('events');
const Redis = require('redis');

class UnifiedNotificationService extends EventEmitter {
    constructor() {
        super();
        this.initializeServices();
        this.setupEventHandlers();
        this.setupQueue();
        this.setupMonitoring();
        this.setupFailover();
        this.startHealthChecks();
    }

    /**
     * üèóÔ∏è „Çµ„Éº„Éì„ÇπÂàùÊúüÂåñ
     */
    async initializeServices() {
        try {
            // ÂêÑ„Çµ„Éº„Éì„ÇπÂàùÊúüÂåñ
            this.smsService = new SMSNotificationService();
            this.pushService = new PushNotificationService();
            this.aiOptimizer = new AINotificationOptimizer();
            
            // RedisÊé•Á∂öÔºà„Ç≠„É•„Éº„Éª„Ç≠„É£„ÉÉ„Ç∑„É•Áî®Ôºâ
            this.redis = Redis.createClient({
                url: process.env.REDIS_URL || 'redis://localhost:6379'
            });
            await this.redis.connect();

            // Áµ±ÂêàË®≠ÂÆö
            this.config = {
                maxRetries: 3,
                retryDelay: 1000,
                batchSize: 100,
                queueProcessInterval: 5000,
                healthCheckInterval: 30000,
                fallbackChannels: ['sms', 'push', 'email'],
                priorityThresholds: {
                    critical: 9,
                    high: 7,
                    medium: 5,
                    low: 3
                }
            };

            // Áä∂ÊÖãÁÆ°ÁêÜ
            this.serviceStatus = {
                sms: 'healthy',
                push: 'healthy',
                email: 'healthy',
                ai: 'healthy',
                overall: 'healthy'
            };

            // Áµ±Ë®à„Éª„É°„Éà„É™„ÇØ„Çπ
            this.metrics = {
                totalSent: 0,
                successRate: 0,
                avgResponseTime: 0,
                channelStats: new Map(),
                errorRates: new Map(),
                conversionRates: new Map()
            };

            this.isInitialized = true;
            console.log('üöÄ UnifiedNotificationService initialized successfully');

        } catch (error) {
            console.error('Service initialization failed:', error);
            this.isInitialized = false;
        }
    }

    /**
     * üéØ „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÉºË®≠ÂÆö
     */
    setupEventHandlers() {
        // ÈÄöÁü•ÈÄÅ‰ø°ÊàêÂäü„Ç§„Éô„É≥„Éà
        this.on('notification_sent', this.handleNotificationSent.bind(this));
        
        // ÈÄöÁü•ÈÄÅ‰ø°Â§±Êïó„Ç§„Éô„É≥„Éà
        this.on('notification_failed', this.handleNotificationFailed.bind(this));
        
        // „É¶„Éº„Ç∂„Éº„Ç®„É≥„Ç≤„Éº„Ç∏„É°„É≥„Éà„Ç§„Éô„É≥„Éà
        this.on('user_engaged', this.handleUserEngagement.bind(this));
        
        // „Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº„Ç§„Éô„É≥„Éà
        this.on('system_error', this.handleSystemError.bind(this));
        
        // „Çµ„Éº„Éì„ÇπÂÅ•ÂÖ®ÊÄßÂ§âÊõ¥„Ç§„Éô„É≥„Éà
        this.on('service_health_changed', this.handleServiceHealthChange.bind(this));
    }

    /**
     * üì¨ „Ç≠„É•„Éº„Ç∑„Çπ„ÉÜ„É†Ë®≠ÂÆö
     */
    setupQueue() {
        this.notificationQueue = {
            critical: [],
            high: [],
            medium: [],
            low: []
        };

        // „Ç≠„É•„ÉºÂá¶ÁêÜÈñãÂßã
        setInterval(() => {
            this.processQueue();
        }, this.config.queueProcessInterval);
    }

    /**
     * üìä Áõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†Ë®≠ÂÆö
     */
    setupMonitoring() {
        this.monitoring = {
            responseTimeTracking: new Map(),
            errorTracking: new Map(),
            performanceMetrics: new Map(),
            alertThresholds: {
                errorRate: 0.05, // 5%
                responseTime: 5000, // 5Áßí
                queueSize: 1000
            }
        };
    }

    /**
     * üõ°Ô∏è „Éï„Çß„Ç§„É´„Ç™„Éº„Éê„ÉºË®≠ÂÆö
     */
    setupFailover() {
        this.failover = {
            channelPriority: ['push', 'sms', 'email'],
            autoFailover: true,
            circuitBreaker: new Map(),
            healthCheckFailures: new Map()
        };
    }

    /**
     * ‚ù§Ô∏è „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÈñãÂßã
     */
    startHealthChecks() {
        setInterval(async () => {
            await this.performHealthChecks();
        }, this.config.healthCheckInterval);
    }

    /**
     * üéØ „É°„Ç§„É≥ÈÄöÁü•ÈÄÅ‰ø°„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπÔºàÂè≤‰∏äÊúÄÂº∑Ôºâ
     */
    async sendNotification(notificationRequest) {
        const startTime = Date.now();
        
        try {
            // „É™„ÇØ„Ç®„Çπ„ÉàÊ§úË®º
            this.validateNotificationRequest(notificationRequest);
            
            // AIÊúÄÈÅ©ÂåñÂÆüË°å
            const optimization = await this.aiOptimizer.optimizeNotification(
                notificationRequest.userId,
                notificationRequest.notification,
                notificationRequest.context || {}
            );

            // ÊúÄÈÅ©ÂåñÁµêÊûúÈÅ©Áî®
            const optimizedRequest = this.applyOptimization(notificationRequest, optimization);

            // ÈÄÅ‰ø°ÂÆüË°å
            const result = await this.executeNotificationSending(optimizedRequest);

            // ÁµêÊûúË®òÈå≤
            this.recordSendingResult(result, startTime);

            return {
                success: true,
                messageId: result.messageId,
                channels: result.channels,
                optimization: optimization,
                metrics: {
                    responseTime: Date.now() - startTime,
                    channelsUsed: result.channels.length,
                    optimizationApplied: true
                }
            };

        } catch (error) {
            console.error('Unified notification sending failed:', error);
            
            this.emit('notification_failed', {
                request: notificationRequest,
                error: error.message,
                timestamp: new Date()
            });

            return {
                success: false,
                error: error.message,
                fallbackAttempted: await this.attemptFallback(notificationRequest)
            };
        }
    }

    /**
     * üö® Á∑äÊÄ•„Ç≠„É£„É≥„Çª„É´ÂæÖ„Å°ÈÄöÁü•ÔºàÂè≤‰∏äÊúÄÂº∑ÂÑ™ÂÖàÂ∫¶Ôºâ
     */
    async sendCancellationAlert(userId, hotelData, options = {}) {
        const emergencyNotification = {
            userId: userId,
            type: 'cancellation_alert',
            priority: 'critical',
            notification: {
                title: 'üè® „Ç≠„É£„É≥„Çª„É´ÂæÖ„Å°ÈÄöÁü•',
                body: `${hotelData.name}„Å´Á©∫ÂÆ§„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„ÅüÔºÅ`,
                data: {
                    hotelId: hotelData.id,
                    hotelName: hotelData.name,
                    checkInDate: hotelData.checkInDate,
                    checkOutDate: hotelData.checkOutDate,
                    roomType: hotelData.roomType,
                    price: hotelData.price,
                    bookingUrl: hotelData.bookingUrl,
                    urgency: 'critical',
                    expiresAt: new Date(Date.now() + 10 * 60 * 1000) // 10ÂàÜÊúâÂäπ
                }
            },
            channels: ['push', 'sms'], // Ë§áÊï∞„ÉÅ„É£„É≥„Éç„É´Âº∑Âà∂
            context: {
                urgency: 'critical',
                bypassQuietHours: true,
                bypassDailyLimit: true,
                requireDeliveryConfirmation: true,
                maxRetries: 5
            },
            ...options
        };

        return await this.sendNotification(emergencyNotification);
    }

    /**
     * üí∞ ‰æ°Ê†º‰∏ãËêΩ„Ç¢„É©„Éº„ÉàÈÄÅ‰ø°
     */
    async sendPriceDropAlert(userId, hotelData, priceInfo, options = {}) {
        const priceAlert = {
            userId: userId,
            type: 'price_drop',
            priority: 'high',
            notification: {
                title: 'üí∞ ‰æ°Ê†º‰∏ãËêΩ„Ç¢„É©„Éº„Éà',
                body: `${hotelData.name}„Åå${priceInfo.discountPercentage}%OFFÔºÅ`,
                data: {
                    hotelId: hotelData.id,
                    hotelName: hotelData.name,
                    originalPrice: priceInfo.originalPrice,
                    newPrice: priceInfo.newPrice,
                    discountPercentage: priceInfo.discountPercentage,
                    bookingUrl: hotelData.bookingUrl,
                    validUntil: priceInfo.validUntil
                }
            },
            context: {
                urgency: 'high',
                category: 'price_alert'
            },
            ...options
        };

        return await this.sendNotification(priceAlert);
    }

    /**
     * ‚ö° „Éï„É©„ÉÉ„Ç∑„É•„Çª„Éº„É´ÈÄöÁü•ÈÄÅ‰ø°
     */
    async sendFlashSaleAlert(userIds, saleData, options = {}) {
        const batchNotifications = userIds.map(userId => ({
            userId: userId,
            type: 'flash_sale',
            priority: 'high',
            notification: {
                title: '‚ö° „Éï„É©„ÉÉ„Ç∑„É•„Çª„Éº„É´ÈñãÂßãÔºÅ',
                body: `${saleData.hotelName} - ÊúÄÂ§ß${saleData.maxDiscount}%OFF`,
                data: {
                    saleId: saleData.id,
                    hotelName: saleData.hotelName,
                    maxDiscount: saleData.maxDiscount,
                    duration: saleData.duration,
                    saleUrl: saleData.url,
                    startsAt: saleData.startsAt,
                    endsAt: saleData.endsAt
                }
            },
            context: {
                urgency: 'high',
                category: 'flash_sale'
            },
            ...options
        }));

        return await this.sendBatchNotifications(batchNotifications);
    }

    /**
     * üì® „Éê„ÉÉ„ÉÅÈÄöÁü•ÈÄÅ‰ø°
     */
    async sendBatchNotifications(notifications) {
        const results = [];
        const batchSize = this.config.batchSize;

        for (let i = 0; i < notifications.length; i += batchSize) {
            const batch = notifications.slice(i, i + batchSize);
            const batchPromises = batch.map(notification => 
                this.sendNotification(notification).catch(error => ({
                    success: false,
                    error: error.message,
                    notification: notification
                }))
            );

            const batchResults = await Promise.allSettled(batchPromises);
            results.push(...batchResults.map(result => result.value || result.reason));

            // „Éê„ÉÉ„ÉÅÈñì„ÅÆÂ∞è‰ºëÊÜ©Ôºà„É¨„Éº„ÉàÂà∂ÈôêÂØæÁ≠ñÔºâ
            if (i + batchSize < notifications.length) {
                await this.sleep(100);
            }
        }

        return {
            totalSent: results.filter(r => r.success).length,
            totalFailed: results.filter(r => !r.success).length,
            results: results
        };
    }

    /**
     * üéØ ÊúÄÈÅ©ÂåñÈÅ©Áî®
     */
    applyOptimization(request, optimization) {
        const optimized = { ...request };

        // „Çø„Ç§„Éü„É≥„Ç∞ÊúÄÈÅ©Âåñ
        if (optimization.optimizedTiming && optimization.optimizedTiming.recommendedTime) {
            optimized.scheduledAt = optimization.optimizedTiming.recommendedTime;
        }

        // „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Éë„Éº„ÇΩ„Éä„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
        if (optimization.personalizedContent) {
            optimized.notification = {
                ...optimized.notification,
                ...optimization.personalizedContent
            };
        }

        // „ÉÅ„É£„É≥„Éç„É´Êé®Â•®
        if (optimization.channelRecommendation) {
            optimized.channels = [optimization.channelRecommendation.primary];
            if (optimization.channelRecommendation.multiChannel) {
                optimized.channels.push(...Object.keys(optimization.channelRecommendation.scores)
                    .filter(channel => channel !== optimization.channelRecommendation.primary)
                    .sort((a, b) => optimization.channelRecommendation.scores[b] - optimization.channelRecommendation.scores[a])
                    .slice(0, 2)
                );
            }
        }

        // ÂÑ™ÂÖàÂ∫¶Ë™øÊï¥
        if (optimization.priorityScore) {
            optimized.priority = this.mapScoreToPriority(optimization.priorityScore);
        }

        // „É°„Çø„Éá„Éº„ÇøËøΩÂä†
        optimized.metadata = {
            ...optimized.metadata,
            aiOptimized: true,
            optimizationVersion: '1.0.0',
            confidenceScore: optimization.confidenceScore,
            predictedEngagement: optimization.predictedEngagement
        };

        return optimized;
    }

    /**
     * üì§ ÈÄöÁü•ÈÄÅ‰ø°ÂÆüË°å
     */
    async executeNotificationSending(request) {
        const results = [];
        const channels = request.channels || ['push'];

        for (const channel of channels) {
            try {
                const result = await this.sendViaChannel(channel, request);
                results.push({
                    channel: channel,
                    success: true,
                    messageId: result.messageId,
                    details: result
                });

                // ÊàêÂäü„Åó„Åü„Çâ‰ªñ„ÅÆ„ÉÅ„É£„É≥„Éç„É´„ÅØ„Çπ„Ç≠„ÉÉ„ÉóÔºàË®≠ÂÆö„Å´„Çà„ÇãÔºâ
                if (request.context?.singleChannelSuccess) {
                    break;
                }

            } catch (error) {
                results.push({
                    channel: channel,
                    success: false,
                    error: error.message
                });

                // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Å™ÈÄöÁü•„ÅÆÂ†¥Âêà„ÅØÊ¨°„ÅÆ„ÉÅ„É£„É≥„Éç„É´„ÇíË©¶Ë°å
                if (request.priority === 'critical') {
                    continue;
                }
            }
        }

        const successfulChannels = results.filter(r => r.success);
        if (successfulChannels.length === 0) {
            throw new Error('All channels failed');
        }

        return {
            messageId: successfulChannels[0].messageId,
            channels: successfulChannels.map(r => r.channel),
            results: results
        };
    }

    /**
     * üì± „ÉÅ„É£„É≥„Éç„É´Âà•ÈÄÅ‰ø°
     */
    async sendViaChannel(channel, request) {
        switch (channel.toLowerCase()) {
            case 'sms':
                return await this.smsService.sendSMS(
                    request.phoneNumber || await this.getUserPhoneNumber(request.userId),
                    this.formatForSMS(request.notification),
                    request.context
                );

            case 'push':
                return await this.pushService.sendToUser(
                    request.userId,
                    request.notification,
                    request.context
                );

            case 'email':
                return await this.sendEmail(request);

            case 'line':
                return await this.sendLineMessage(request);

            default:
                throw new Error(`Unsupported channel: ${channel}`);
        }
    }

    /**
     * üìß „É°„Éº„É´ÈÄÅ‰ø°ÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
     */
    async sendEmail(request) {
        // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØÊó¢Â≠ò„ÅÆEmailNotificationService„Çí‰ΩøÁî®
        console.log('üìß Email notification sent (mock):', request.notification.title);
        return {
            messageId: 'email_' + Date.now(),
            status: 'sent'
        };
    }

    /**
     * üí¨ LINEÈÄÅ‰ø°ÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
     */
    async sendLineMessage(request) {
        // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØÊó¢Â≠ò„ÅÆLineNotificationService„Çí‰ΩøÁî®
        console.log('üí¨ LINE notification sent (mock):', request.notification.title);
        return {
            messageId: 'line_' + Date.now(),
            status: 'sent'
        };
    }

    /**
     * üîÑ „Ç≠„É•„ÉºÂá¶ÁêÜ
     */
    async processQueue() {
        const priorities = ['critical', 'high', 'medium', 'low'];
        
        for (const priority of priorities) {
            const queue = this.notificationQueue[priority];
            if (queue.length === 0) continue;

            // „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫ÂàÜÂá¶ÁêÜ
            const batch = queue.splice(0, this.config.batchSize);
            const promises = batch.map(notification => 
                this.sendNotification(notification).catch(error => ({
                    success: false,
                    error: error.message
                }))
            );

            await Promise.allSettled(promises);
        }
    }

    /**
     * üõ°Ô∏è „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØË©¶Ë°å
     */
    async attemptFallback(request) {
        try {
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÉÅ„É£„É≥„Éç„É´„ÅßÂÜçË©¶Ë°å
            const fallbackChannels = this.config.fallbackChannels.filter(
                channel => !request.channels?.includes(channel)
            );

            if (fallbackChannels.length === 0) {
                return false;
            }

            const fallbackRequest = {
                ...request,
                channels: fallbackChannels.slice(0, 1),
                context: {
                    ...request.context,
                    isFallback: true
                }
            };

            const result = await this.sendNotification(fallbackRequest);
            return result.success;

        } catch (error) {
            console.error('Fallback also failed:', error);
            return false;
        }
    }

    /**
     * ‚ù§Ô∏è „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÂÆüË°å
     */
    async performHealthChecks() {
        const healthChecks = {
            sms: () => this.smsService.getStatistics(),
            push: () => this.pushService.getStatistics(),
            ai: () => this.aiOptimizer.getStatistics(),
            redis: () => this.redis.ping()
        };

        for (const [service, checkFn] of Object.entries(healthChecks)) {
            try {
                await checkFn();
                this.updateServiceHealth(service, 'healthy');
            } catch (error) {
                this.updateServiceHealth(service, 'unhealthy');
                console.error(`Health check failed for ${service}:`, error);
            }
        }

        this.updateOverallHealth();
    }

    /**
     * üè• „Çµ„Éº„Éì„ÇπÂÅ•ÂÖ®ÊÄßÊõ¥Êñ∞
     */
    updateServiceHealth(service, status) {
        if (this.serviceStatus[service] !== status) {
            this.serviceStatus[service] = status;
            this.emit('service_health_changed', { service, status });
        }
    }

    /**
     * üè• ÂÖ®‰ΩìÂÅ•ÂÖ®ÊÄßÊõ¥Êñ∞
     */
    updateOverallHealth() {
        const healthyServices = Object.values(this.serviceStatus).filter(status => status === 'healthy').length;
        const totalServices = Object.keys(this.serviceStatus).length - 1; // 'overall'„ÇíÈô§„Åè
        
        if (healthyServices === totalServices) {
            this.serviceStatus.overall = 'healthy';
        } else if (healthyServices >= totalServices * 0.5) {
            this.serviceStatus.overall = 'degraded';
        } else {
            this.serviceStatus.overall = 'unhealthy';
        }
    }

    /**
     * üìä „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÉºÁæ§
     */
    handleNotificationSent(data) {
        this.metrics.totalSent++;
        this.updateChannelStats(data.channel, 'sent');
    }

    handleNotificationFailed(data) {
        this.updateChannelStats(data.channel, 'failed');
        this.metrics.errorRates.set(data.channel, 
            (this.metrics.errorRates.get(data.channel) || 0) + 1
        );
    }

    handleUserEngagement(data) {
        this.metrics.conversionRates.set(data.type,
            (this.metrics.conversionRates.get(data.type) || 0) + 1
        );
    }

    handleSystemError(data) {
        console.error('System error detected:', data);
        // „Ç¢„É©„Éº„ÉàÈÄÅ‰ø°„Å™„Å©„ÅÆÂá¶ÁêÜ
    }

    handleServiceHealthChange(data) {
        console.log(`Service health changed: ${data.service} -> ${data.status}`);
        // ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÈÅãÁî®„ÉÅ„Éº„É†„Å´ÈÄöÁü•
    }

    /**
     * üîß „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£„É°„ÇΩ„ÉÉ„ÉâÁæ§
     */
    validateNotificationRequest(request) {
        if (!request.userId) {
            throw new Error('userId is required');
        }
        if (!request.notification) {
            throw new Error('notification object is required');
        }
        if (!request.notification.title && !request.notification.body) {
            throw new Error('notification must have title or body');
        }
    }

    formatForSMS(notification) {
        return `${notification.title}\n${notification.body || ''}`.trim();
    }

    async getUserPhoneNumber(userId) {
        // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„Éá„Éº„Çø„Éô„Éº„Çπ„Åã„ÇâÂèñÂæó
        return '+819012345678'; // „É¢„ÉÉ„ÇØ
    }

    mapScoreToPriority(score) {
        if (score >= this.config.priorityThresholds.critical) return 'critical';
        if (score >= this.config.priorityThresholds.high) return 'high';
        if (score >= this.config.priorityThresholds.medium) return 'medium';
        return 'low';
    }

    updateChannelStats(channel, action) {
        if (!this.metrics.channelStats.has(channel)) {
            this.metrics.channelStats.set(channel, { sent: 0, failed: 0 });
        }
        this.metrics.channelStats.get(channel)[action]++;
    }

    recordSendingResult(result, startTime) {
        const responseTime = Date.now() - startTime;
        this.metrics.avgResponseTime = (this.metrics.avgResponseTime + responseTime) / 2;
        
        // ÊàêÂäüÁéáÊõ¥Êñ∞
        const totalAttempts = this.metrics.totalSent + 
            Array.from(this.metrics.errorRates.values()).reduce((sum, count) => sum + count, 0);
        this.metrics.successRate = this.metrics.totalSent / totalAttempts;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * üìä Áµ±Ë®àÊÉÖÂ†±ÂèñÂæó
     */
    getStatistics() {
        return {
            service: {
                initialized: this.isInitialized,
                health: this.serviceStatus,
                uptime: process.uptime()
            },
            metrics: {
                totalSent: this.metrics.totalSent,
                successRate: this.metrics.successRate,
                avgResponseTime: this.metrics.avgResponseTime,
                channelStats: Object.fromEntries(this.metrics.channelStats),
                errorRates: Object.fromEntries(this.metrics.errorRates)
            },
            queue: {
                critical: this.notificationQueue.critical.length,
                high: this.notificationQueue.high.length,
                medium: this.notificationQueue.medium.length,
                low: this.notificationQueue.low.length
            },
            subServices: {
                sms: this.smsService?.getStatistics() || {},
                push: this.pushService?.getStatistics() || {},
                ai: this.aiOptimizer?.getStatistics() || {}
            }
        };
    }

    /**
     * üõë „Çµ„Éº„Éì„ÇπÂÅúÊ≠¢
     */
    async shutdown() {
        console.log('üõë Shutting down UnifiedNotificationService...');
        
        try {
            // RedisÊé•Á∂ö„ÇØ„É≠„Éº„Ç∫
            await this.redis.disconnect();
            
            // ÂêÑ„Çµ„Éº„Éì„Çπ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØÂêÑ„Çµ„Éº„Éì„Çπ„ÅÆshutdown„É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åó
            
            console.log('‚úÖ UnifiedNotificationService shutdown complete');
        } catch (error) {
            console.error('Error during shutdown:', error);
        }
    }
}

module.exports = UnifiedNotificationService;